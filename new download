import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  Box,
  Container,
  Typography,
  Alert,
  IconButton,
  Checkbox,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Button,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  CircularProgress,
  Paper
} from '@mui/material';
import {
  Close as CloseIcon,
  Visibility as VisibilityIcon,
  PictureAsPdf as PictureAsPdfIcon,
  Description as DescriptionIcon, // Generic for Excel/Text or use more specific ones
  WarningAmber as WarningIcon,
} from '@mui/icons-material';

// Native file download helper function
const downloadFileNatively = (blob, fileName) => {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.style.display = 'none';
  a.href = url;
  a.download = fileName;
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(url);
  document.body.removeChild(a);
};


// Simulated sessionUser - replace with your actual session user data/context
const mockSessionUser = {
  capacity: '61', // Example, change to test different headings
  circleCode: 'ABC',
  circleName: 'ExampleCircle',
  quarterEndDate: '2025-Q1', // Example date, updated to current year
  // ... other user properties
};

// Placeholder for API functions - replace with your actual API logic
const api = {
  getBranchList: async (sessionUser) => {
    console.log("API: getBranchList called with", sessionUser);
    // Simulate API delay and return mock data
    await new Promise(resolve => setTimeout(resolve, 500));
    return [{ branchCode: 'B001' }, { branchCode: 'B002' }, { branchCode: 'All Branches' }];
  },
  getListOfReports: async (sessionUser) => {
    console.log("API: getListOfReports called with", sessionUser);
    await new Promise(resolve => setTimeout(resolve, 500));
    return { // Mock data structure
        list1: [
            { id: 'r1', dash_name: 'Report Alpha', dash_suppresed: 'Z', dash_dwnload: 'HPEZC', type: 'PRE', circle: '', branchCode: '', dash_param: 'TYPE;BRANCH_CODE;COMP' },
            { id: 'r2', dash_name: 'Report Beta', dash_suppresed: 'N', dash_dwnload: 'HPE', type: 'POST', circle: '', branchCode: '', dash_param: 'TYPE;CIRCLE_LIST' },
            { id: 'r3', dash_name: 'Report Gamma (No Suppress)', dash_suppresed: 'N', dash_dwnload: 'HPET', type: 'PRE', circle: '', branchCode: '', dash_param: 'TYPE' },
            { id: 'r4', dash_name: 'Report Delta (CSV only)', dash_suppresed: 'Z', dash_dwnload: 'C', type: 'INTERSE', circle: '', branchCode: '', dash_param: 'TYPESE;BRANCH_CODE' },
        ],
        list: [
            { circleCode: 'C001', circleName: 'Circle 1' }, { circleCode: 'C002', circleName: 'Circle 2' }
        ],
        freezedCircles: [
            { circleCode: 'FC001', circleName: 'Frozen Circle 1' }
        ],
    };
  },
  viewReportCircle: async (params) => {
    console.log("API: viewReportCircle called with", params);
    await new Promise(resolve => setTimeout(resolve, 500));
    // Simulate returning a blob based on action
    let content = `Mock data for ${params.report.dash_name} (${params.type})`;
    let contentType = 'application/octet-stream';
    if (params.type === 'view') contentType = 'text/html';
    if (params.type === 'downloadPDF') contentType = 'application/pdf';
    if (params.type === 'download') contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    if (params.type && params.type.startsWith('downloadCSV')) contentType = 'text/plain;charset=utf-8';
    return new Blob([content], { type: contentType });
  },
  viewReport: async (params) => {
    console.log("API: viewReport called with", params);
    await new Promise(resolve => setTimeout(resolve, 500));
    let content = `Mock FRT data for ${params.report.dash_name} (${params.type})`;
    let contentType = 'application/octet-stream';
    if (params.type === 'view') contentType = 'application/pdf'; // FRT view was PDF
    if (params.type === 'downloadPDF') contentType = 'application/pdf';
    if (params.type === 'download') contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    return new Blob([content], { type: contentType });
  },
};


const ReportsComponent = () => {
  const [sessionUser] = useState(mockSessionUser);
  const [heading, setHeading] = useState('');
  const [branchList, setBranchList] = useState([]);
  const [listOfRows, setListOfRows] = useState([]);
  const [listOfCircle, setListOfCircle] = useState([]);
  const [freezedCircles, setFreezedCircles] = useState([]);
  const [selectedBranchCode, setSelectedBranchCode] = useState('All Branches');
  const [showDiv, setShowDiv] = useState(false);
  const [showAltMessage, setShowAltMessage] = useState(false);
  const [componentMessage, setComponentMessage] = useState('');
  const [checkCircle, setCheckCircle] = useState(false);
  const [checkCircleMessage, setCheckCircleMessage] = useState('');
  const [pdfContentUrl, setPdfContentUrl] = useState('');
  const [loading, setLoading] = useState(false);
  const [rowStates, setRowStates] = useState({});
  const [csvModalOpen, setCsvModalOpen] = useState(false);
  const [csvModalParams, setCsvModalParams] = useState(null);

  useEffect(() => {
    const initialRowStates = {};
    listOfRows.forEach((row, index) => {
      initialRowStates[index] = {
        isSuppressed: false,
        branchCode: row.dash_param && row.dash_param.includes('BRANCH_CODE') ? (branchList.find(b => b.branchCode === 'All Branches') ? 'All Branches' : (branchList[0]?.branchCode || '')) : '',
        type: 'PRE',
        circle: [],
      };
    });
    setRowStates(initialRowStates);
  }, [listOfRows, branchList]);

  const handleRowStateChange = (index, field, value) => {
    setRowStates(prev => ({
      ...prev,
      [index]: {
        ...prev[index],
        [field]: value,
      },
    }));
  };

  useEffect(() => {
    if (!sessionUser || !sessionUser.capacity) return;
    const capacity = sessionUser.capacity;
    // Simplified logic from JSP, adjust if needed.
    // Original logic comments: if 61/62 -> 1; if 51/52/53 -> 2; if 61 -> 4 (overrides); else 3
    if (capacity === '61') {
      setHeading('4');
    } else if (['51', '52', '53'].includes(capacity)) {
        setHeading('2');
    } else if (capacity === '62') { // Assuming '62' should behave like '1' if '4' is specific to '61'
        setHeading('1'); // You might need to clarify what '1' represents if '4' and '2' are primary
    }
     else {
      setHeading('3');
    }
  }, [sessionUser]);

  useEffect(() => {
    const fetchData = async () => {
      if (!sessionUser) return;
      setLoading(true);
      try {
        const branches = await api.getBranchList(sessionUser);
        setBranchList(branches);
        // Set default selectedBranchCode based on fetched branches
        if (branches.find(b => b.branchCode === 'All Branches')) {
            setSelectedBranchCode('All Branches');
        } else if (branches.length > 0) {
            setSelectedBranchCode(branches[0].branchCode);
        }


        const reportsData = await api.getListOfReports(sessionUser);
        if (reportsData.list1 && reportsData.list1.length > 0) {
          setShowDiv(true);
          setListOfRows(reportsData.list1);
          setListOfCircle(reportsData.list || []);
          setFreezedCircles(reportsData.freezedCircles || []);

          const listWithZ = reportsData.list1.filter(row => row.dash_suppresed === 'Z');
          setShowAltMessage(listWithZ.length > 0);
          setComponentMessage('');
        } else {
          setComponentMessage('No reports are found to download.');
          setShowDiv(false);
        }
      } catch (error) {
        console.error('Error fetching initial data:', error);
        setComponentMessage('Failed to load reports data.');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [sessionUser]);

  const clearCheckCircleAlert = () => {
    setCheckCircle(false);
    setCheckCircleMessage('');
  };

  const handleViewReportJrxmlCircle = async (index, action, report) => {
    if (!rowStates[index]) return;
    const currentRowState = rowStates[index];
    const { type: prePost, circle: compcircle, branchCode } = currentRowState;
    const { dash_suppresed, dash_param } = report;
    const isSuppressed = currentRowState.isSuppressed;

    let prePostValue = "";
    if (dash_param && dash_param.includes('TYPE')) {
      prePostValue = "_" + prePost;
    }

    let saveAsNamePrefix = "";
    if (!branchCode || branchCode === "All Branches") {
      saveAsNamePrefix = sessionUser.circleName ? sessionUser.circleName.substring(0, 3) : "CIR";
    } else {
      saveAsNamePrefix = branchCode;
    }
    const reportBaseName = report.dash_name ? report.dash_name.replace(/[^a-z0-9_.-]/gi, '_') : 'report';
    const finalSaveAsName = `${saveAsNamePrefix}_${sessionUser.quarterEndDate || 'QEND'}_${reportBaseName}${prePostValue}`;


    const apiParams = {
      report,
      user: sessionUser,
      type: action,
      prePost,
      compcircle: Array.isArray(compcircle) ? compcircle.join(',') : compcircle,
      branchCode,
      dash_suppresed,
      isSuppresed: isSuppressed,
    };

    setLoading(true);
    setPdfContentUrl(''); // Clear previous content
    try {
      const dataBlob = await api.viewReportCircle(apiParams);

      if (action === "view") {
        const fileType = (report.dash_name || '').toLowerCase().includes('html') ? 'text/html' : 'application/pdf'; // Basic assumption
         // For view, if it's HTML content, it might be handled differently than PDF
        if (fileType === 'text/html' && dataBlob.type.includes('html')) {
            const url = URL.createObjectURL(dataBlob);
            setPdfContentUrl(url); // Use iframe for HTML or PDF
             // MS specific behavior from original code - not directly replicable without ActiveX or specific browser handling for HTML download
            if (window.navigator && window.navigator.msSaveOrOpenBlob) {
                 // This was used for HTML in original angular, let's try to download it instead of iframe for IE/Edge legacy
                 downloadFileNatively(dataBlob, finalSaveAsName + ".html");
                 setPdfContentUrl(''); // Don't show in iframe if msSaveOrOpenBlob is used
            }
        } else { // Assuming PDF or other embeddable content for iframe
            const url = URL.createObjectURL(dataBlob);
            setPdfContentUrl(url);
        }
      } else if (action === "downloadPDF") {
        downloadFileNatively(dataBlob, finalSaveAsName + ".pdf");
      } else if (action === "download") { // Excel
        downloadFileNatively(dataBlob, finalSaveAsName + ".xlsx");
      } else if (action && action.startsWith("downloadCSV")) {
        const extensionType = action.substring(11, 12);
        let extension = ".txt"; // Default based on original code
        // if (extensionType === "C") { // Logic from original was just .txt for both
        // }
        downloadFileNatively(dataBlob, finalSaveAsName + extension);
      }
    } catch (error) {
      console.error('Error in viewReportJrxmlCircle:', error);
      setCheckCircle(true);
      setCheckCircleMessage(`Error processing report request: ${error.message}`);
    } finally {
      setLoading(false);
    }
  };

  const handleViewReportJrxml = async (index, action, report) => {
    if (!rowStates[index]) return;
    const currentRowState = rowStates[index];
    const { type: prePost, circle: compcircle } = currentRowState;
    const { dash_suppresed, dash_param } = report;
    const isSuppressed = currentRowState.isSuppressed;

    setCheckCircle(false);
    setPdfContentUrl('');

    let prePostValue = "";
    if (dash_param && dash_param.includes('TYPE')) {
        prePostValue = "_" + prePost;
    }
    const reportBaseName = report.dash_name ? report.dash_name.replace(/[^a-z0-9_.-]/gi, '_') : 'report';
    const finalSaveAsName = `${sessionUser.circleName ? sessionUser.circleName.substring(0, 3) : "FRT"}_${sessionUser.quarterEndDate || 'QEND'}_${reportBaseName}${prePostValue}`;

    if ((compcircle === undefined || (Array.isArray(compcircle) && compcircle.length === 0)) && dash_param && dash_param.includes('COMP')) {
      setCheckCircleMessage("Please select circle");
      setCheckCircle(true);
      return;
    }
    if ((compcircle === undefined || (Array.isArray(compcircle) && compcircle.length === 0)) && dash_param && dash_param.includes('CIRCLE_LIST') && freezedCircles.length > 0) {
        setCheckCircleMessage("Please select circle from Freezed Circles list.");
        setCheckCircle(true);
        return;
    } else if (freezedCircles.length === 0 && dash_param && dash_param.includes('CIRCLE_LIST')) {
        setCheckCircleMessage("No circle has been freezed to generate Consolidation Report");
        setCheckCircle(true);
        return;
    }

    const apiParams = {
      report,
      user: sessionUser,
      type: action,
      prePost,
      compcircle: Array.isArray(compcircle) ? compcircle.join(',') : compcircle,
      dash_suppresed,
      isSuppresed: isSuppressed,
    };

    setLoading(true);
    try {
      const dataBlob = await api.viewReport(apiParams);
      if (action === "view") { // FRT level view was PDF
        if (window.navigator && window.navigator.msSaveOrOpenBlob) { // IE/Edge legacy
            downloadFileNatively(dataBlob, finalSaveAsName + ".pdf");
        } else {
            const url = URL.createObjectURL(dataBlob);
            setPdfContentUrl(url);
        }
      } else if (action === "downloadPDF") {
        downloadFileNatively(dataBlob, finalSaveAsName + ".pdf");
      } else if (action === "download") { // Excel
        downloadFileNatively(dataBlob, finalSaveAsName + ".xlsx");
      }
    } catch (error) {
      console.error('Error in viewReportJrxml:', error);
      setCheckCircle(true);
      setCheckCircleMessage(`Error processing report request: ${error.message}`);
    } finally {
      setLoading(false);
    }
  };

  const handleCheckCsv = (index, action, report) => {
    if (!rowStates[index]) return;
    const currentRowState = rowStates[index];
     const { type: prePost, circle: compcircle, branchCode } = currentRowState; // Get current state
    const { dash_suppresed, dash_param } = report;
    const isSuppressed = currentRowState.isSuppressed;

    setCsvModalParams({ index, action, prePost, compcircle, branchCode, dash_suppresed, isSuppressed, dash_param, report });
    setCsvModalOpen(true);
  };

  const handleCsvModalContinue = () => {
    if (csvModalParams) {
      const { index, action, report } = csvModalParams;
      // The original Angular code calls viewReportJrxmlCircle from the modal's continue button.
      handleViewReportJrxmlCircle(index, action, report);
    }
    setCsvModalOpen(false);
  };

  const renderTableHeaders = () => {
    // ... (Header rendering logic remains the same as previous version)
    if (heading === '3') {
      return (
        <TableRow>
          <TableCell>Report Name</TableCell>
          <TableCell>View</TableCell>
          <TableCell></TableCell>
          <TableCell></TableCell>
          <TableCell></TableCell>
          <TableCell></TableCell>
          <TableCell>PRE/POST</TableCell>
        </TableRow>
      );
    }
    if (heading === '5') {
      return (
        <TableRow>
          <TableCell>Report Name</TableCell>
          <TableCell>View</TableCell>
          <TableCell></TableCell>
          <TableCell></TableCell>
          <TableCell></TableCell>
          <TableCell></TableCell>
          <TableCell></TableCell>
        </TableRow>
      );
    }
    const isHeading2 = heading === '2';
    const isHeading1 = heading === '1';

    return (
      <TableRow>
        <TableCell>Report Name</TableCell>
        <TableCell>View (Suppress)</TableCell>
        <TableCell>HTML</TableCell>
        <TableCell>PDF</TableCell>
        <TableCell>Excel</TableCell>
        {isHeading2 && <TableCell>CSV/TXT</TableCell>}
        {(isHeading2 && <TableCell>Circle/Branch</TableCell>) || (isHeading1 && <TableCell></TableCell>)}
        <TableCell>PRE/POST</TableCell>
        {(isHeading2 && <TableCell>CompCode (Circles)</TableCell>) || (isHeading1 && <TableCell>Circles</TableCell>)}
         {heading === '4' && <TableCell></TableCell> /* Extra to match column count if needed */}
      </TableRow>
    );
  };

  const renderTableRows = () => {
    // ... (Row rendering logic needs updates for button actions)
     return listOfRows.map((row, index) => {
      if (!rowStates[index]) {
        // Initialize if not present, though useEffect should handle this
        handleRowStateChange(index, 'isSuppressed', false); // Ensure a default
        return null;
      }
      const currentRowState = rowStates[index];
      const dashDwnload = row.dash_dwnload || "";
      const dashParam = row.dash_param || "";

      const showViewButton = dashDwnload.includes('H');
      const showPdfButton = dashDwnload.includes('P');
      const showExcelButton = dashDwnload.includes('E');
      const showCsvOrTxtButton = dashDwnload.includes('T') || dashDwnload.includes('C');

      // Determine which main action handler to use based on heading
      const actionHandler = (heading === '2' || heading === '4') ? handleViewReportJrxmlCircle : handleViewReportJrxml;

      return (
        <TableRow key={row.id || index}>
          <TableCell>{row.dash_name}</TableCell>
          <TableCell sx={{width: '4%'}}>
            {row.dash_suppresed === 'Z' && (
              <Checkbox
                checked={!!currentRowState.isSuppressed}
                onChange={(e) => handleRowStateChange(index, 'isSuppressed', e.target.checked)}
                size="small"
              />
            )}
          </TableCell>

          {/* Action Buttons */}
          <TableCell sx={{width: '4%'}}>{showViewButton && <Button size="small" onClick={() => actionHandler(index, 'view', row)}><VisibilityIcon /></Button>}</TableCell>
          <TableCell sx={{width: '4%'}}>{showPdfButton && <Button size="small" color="error" onClick={() => actionHandler(index, 'downloadPDF', row)}><PictureAsPdfIcon /></Button>}</TableCell>
          <TableCell sx={{width: '4%'}}>{showExcelButton && <Button size="small" color="success" onClick={() => actionHandler(index, 'download', row)}><DescriptionIcon /></Button>}</TableCell>

          {/* CSV Button (heading '2' only) */}
          {heading === '2' && (
            <TableCell sx={{width: '4%'}}>
              {showCsvOrTxtButton && <Button size="small" color="primary" onClick={() => handleCheckCsv(index, `downloadCSV${dashDwnload.includes('C') ? 'C' : 'T'}`, row)}><DescriptionIcon /></Button>}
            </TableCell>
          )}
          {/* Placeholder for other headings to maintain column structure if CSV column exists for heading 2 */}
          {(heading === '1' || heading === '3' || heading === '4' || heading === '5') && heading !== '2' && <TableCell sx={{width: '4%'}}></TableCell>}


          {/* Conditional inputs based on heading */}
          {/* Circle/Branch Dropdown for heading '2' or '4' (if branch_code exists) */}
          {(heading === '2' || heading === '4') && (
            <TableCell>
              {dashParam.includes('BRANCH_CODE') && (
                <FormControl fullWidth size="small" sx={{minWidth: 120}}>
                  <InputLabel>Branch</InputLabel>
                  <Select
                    value={currentRowState.branchCode || ''}
                    onChange={(e) => handleRowStateChange(index, 'branchCode', e.target.value)}
                    required
                  >
                    {branchList.map(branch => (
                      <MenuItem key={branch.branchCode} value={branch.branchCode}>{branch.branchCode}</MenuItem>
                    ))}
                  </Select>
                </FormControl>
              )}
            </TableCell>
          )}
          {/* Placeholder for headings 1, 3, 5 if branch column exists for 2/4 */}
          {(heading === '1' || heading === '3' || heading === '5') && <TableCell></TableCell>}


          {/* PRE/POST Dropdown - Common to 1, 2, 3, 4 (if TYPE exists) */}
          {(heading === '1' || heading === '2' || heading === '3' || heading === '4') && (
            <TableCell>
              {dashParam.includes('TYPE') && (
                <FormControl fullWidth size="small" sx={{minWidth: 100}}>
                  <InputLabel>Type</InputLabel>
                  <Select
                    value={currentRowState.type || 'PRE'}
                    onChange={(e) => handleRowStateChange(index, 'type', e.target.value)}
                  >
                    <MenuItem value="PRE">PRE</MenuItem>
                    <MenuItem value="POST">POST</MenuItem>
                    {dashParam.includes('TYPESE') && <MenuItem value="INTERSE">INTERSE</MenuItem>}
                  </Select>
                </FormControl>
              )}
            </TableCell>
          )}
           {/* Placeholder for heading 5 if PRE/POST column exists for others */}
          {heading === '5' && <TableCell></TableCell>}


          {/* Circles Dropdown */}
          {/* Heading 2 (CompCode - listOfCircle) */}
          {heading === '2' && (
            <TableCell>
              {dashParam.includes('COMP') && (
                <FormControl fullWidth size="small" sx={{minWidth: 150}}>
                  <InputLabel>Circles (Comp)</InputLabel>
                  <Select
                    multiple
                    value={Array.isArray(currentRowState.circle) ? currentRowState.circle : []}
                    onChange={(e) => handleRowStateChange(index, 'circle', e.target.value)}
                    renderValue={(selected) => selected.map(code => listOfCircle.find(c=>c.circleCode === code)?.circleName || code).join(', ')}
                  >
                    {listOfCircle.map(circle => (
                      <MenuItem key={circle.circleCode} value={circle.circleCode}>
                        <Checkbox checked={(currentRowState.circle || []).indexOf(circle.circleCode) > -1} size="small"/>
                        {circle.circleName}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              )}
            </TableCell>
          )}
          {/* Heading 1 (CIRCLE_LIST from freezedCircles, or COMP from listOfCircle) */}
          {heading === '1' && (
             <TableCell>
                {dashParam.includes('CIRCLE_LIST') && (
                  <FormControl fullWidth size="small" sx={{minWidth: 150}}>
                    <InputLabel>Freezed Circles</InputLabel>
                    <Select
                      multiple
                      value={Array.isArray(currentRowState.circle) ? currentRowState.circle : []}
                      onChange={(e) => handleRowStateChange(index, 'circle', e.target.value)}
                      renderValue={(selected) => selected.map(code => freezedCircles.find(c=>c.circleCode === code)?.circleName || code).join(', ')}
                      required
                    >
                      {freezedCircles.map(circle => (
                        <MenuItem key={circle.circleCode} value={circle.circleCode}>
                           <Checkbox checked={(currentRowState.circle || []).indexOf(circle.circleCode) > -1} size="small"/>
                          {circle.circleName}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                )}
                {dashParam.includes('COMP') && !dashParam.includes('CIRCLE_LIST') && (
                  <FormControl fullWidth size="small" sx={{minWidth: 150}}>
                    <InputLabel>Circle (Comp)</InputLabel>
                    <Select // Assuming single select if not CIRCLE_LIST for heading 1 COMP
                      value={currentRowState.circle || ''} // This was array before, might need to be string if single
                      onChange={(e) => handleRowStateChange(index, 'circle', e.target.value)}
                      required
                    >
                      <MenuItem value="">--Select Circle--</MenuItem>
                      {listOfCircle.map(circle => (
                        <MenuItem key={circle.circleCode} value={circle.circleCode}>{circle.circleName}</MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                )}
             </TableCell>
          )}
          {/* Placeholders for headings 3,4,5 if Circles column exists */}
          {(heading === '3' || heading === '4' || heading === '5') && <TableCell></TableCell>}


        </TableRow>
      );
    });
  };

  if (loading && !showDiv && !componentMessage) {
    return <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}><CircularProgress /></Box>;
  }

  return (
    <Box className="wrapper">
      <Box className="header header-filter" sx={{ backgroundImage: "url('assets/img/bg2.jpeg')", padding: { xs: 2, md: 4 }, color: 'white', mb: 2 }}>
        <Container>
          <Box className="row tim-row" sx={{display: 'flex', justifyContent: 'center'}}>
            <Box className="col-md-8 col-md-offset-2 text-center">
              <Box className="brand">
                <Typography variant="h3" component="h1" style={{ color: 'white' }}>Reports</Typography>
              </Box>
            </Box>
          </Box>
        </Container>
      </Box>

      <Box className="main main-raised" sx={{p: {xs: 1, md: 2}, m: {xs:1, md:2}, position: 'relative' }}>
        {checkCircle && (
          <Alert
            severity="warning"
            icon={<WarningIcon fontSize="inherit" />}
            action={
              <IconButton
                aria-label="close"
                color="inherit"
                size="small"
                onClick={clearCheckCircleAlert}
              >
                <CloseIcon fontSize="inherit" />
              </IconButton>
            }
            sx={{ mb: 2,  ...(checkCircle ? { position: 'sticky', top: 0, zIndex: 1200 } : {}) }}

          >
            {checkCircleMessage}
          </Alert>
        )}

        <Box className="section" sx={{ mt: checkCircle ? 2 : 0 }}>
          <Container maxWidth="xl"> {/* Use maxWidth="xl" or false for full width */}
            <Box className="row">
              {componentMessage && !showDiv && <Typography variant="h5" gutterBottom sx={{textAlign: 'center', my: 3}}><b>{componentMessage}</b></Typography>}
              {showAltMessage && showDiv && (
                <Alert severity="info" sx={{my: 2}}>
                    <Checkbox defaultChecked disabled size="small" sx={{p:0, mr: 0.5}} />
                    Please select the checkbox under "View (Suppress)" for reports marked with '(Z)' in their data to get a zero-suppressed report.
                </Alert>
              )}

              {showDiv && (
                <Paper sx={{ mt: 2, width: '100%', overflowX: 'auto' }}>
                  {loading && <CircularProgress sx={{position: 'absolute', top: '50%', left: '50%', zIndex: 1300}}/>}
                  <TableContainer>
                    <Table id="example1" stickyHeader size="small">
                      <TableHead>
                        {renderTableHeaders()}
                      </TableHead>
                      <TableBody style={{ fontWeight: 400 }}>
                        {renderTableRows()}
                      </TableBody>
                    </Table>
                  </TableContainer>
                </Paper>
              )}

              {pdfContentUrl && (
                <Box sx={{ mt: 3, width: '100%', height: 'calc(100vh - 150px)', minHeight: '500px' }}>
                  <iframe
                    id="visualizador"
                    src={pdfContentUrl}
                    width="100%"
                    height="100%"
                    style={{ border: '1px solid #ccc', overflow: 'auto' }}
                    title="Report Viewer"
                    onLoad={() => URL.revokeObjectURL(pdfContentUrl)} // Revoke object URL when iframe has loaded it
                  ></iframe>
                </Box>
              )}
            </Box>
          </Container>
        </Box>
      </Box>

      <Dialog open={csvModalOpen} onClose={() => setCsvModalOpen(false)} PaperProps={{style: {zIndex: 1400}}}>
        <DialogTitle sx={{ backgroundColor: '#E74C3C', color: 'white' }}>Attention!</DialogTitle>
        <DialogContent>
          <DialogContentText sx={{mt:2}}>
            This file will contain only MOC posted and accepted by circle/Unit for current quarter in BSA.
            Please verify branch wise CR and DR is matching as per Finance Two (F2) before uploading csv into Finance Two (F2).
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCsvModalContinue} variant="contained" color="success">
            Continue
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default ReportsComponent;

